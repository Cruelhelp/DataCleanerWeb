<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Supabase Document Cleaner</title>
    <!--
      Supabase Document Cleaner

      This application replaces the in‑browser Pandas implementation with a server
      side approach powered by Supabase.  Large spreadsheets are uploaded to a
      temporary bucket on Supabase and processed by an Edge Function.  Each
      import is tracked with a unique session ID (backed by the csv_jobs table),
      and detailed logs are streamed back to the browser via Postgres
      subscriptions.  The cleaned records live only for the lifetime of a
      session; deleting the session removes all data and uploaded files.  This
      design ensures that no potentially sensitive content remains in the cloud
      beyond your workflow and avoids exhausting the browser’s memory when
      handling large CSV files.

      To deploy this front‑end you will need:
        1. A Supabase project with the tables and policies described in the
           documentation (see the README in this repository or the answer
           instructions for the required SQL).  In particular the tables
           csv_jobs, csv_job_logs and cleaned_records must exist with row
           level security enabled and policies that allow anonymous inserts
           and selects.
        2. An Edge Function named `process_csv` that reads a CSV from the
           `raw_uploads` bucket, filters rows by item number, groups paths
           and writes results to the cleaned_records table, logging progress
           to csv_job_logs and updating the job status in csv_jobs.
      
      In this file we embed the VS Code‑inspired dark theme, the Supabase
      client library, SheetJS for quick local scanning of a few values, and
      JSZip for compressing the final Excel file on demand.  The UI allows
      users to upload a raw export, scan for unique item numbers, choose a
      subset to process, start the job, monitor logs in real time and then
      download the cleaned data.  A Delete Session button removes all traces
      of the data from Supabase.  Caching in memory prevents redundant
      downloads when re‑filtering or searching.
    -->
    <style>
      /* VS Code–inspired dark theme */
      :root {
        --bg: #1e1e1e;
        --bg2: #252526;
        --bg3: #2d2d2d;
        --fg: #d4d4d4;
        --accent: #007acc;
        --btn: #0e639c;
        --btn-hover: #1177bb;
        --btn-press: #094771;
        --muted: #8a8a8a;
        --border: #2d2d2d;
        --danger: #f14c4c;
        --radius: 6px;
        --font-body: "Segoe UI", "Arial", "Helvetica Neue", Helvetica, sans-serif;
      }
      * { box-sizing: border-box; }
      html, body { height: 100%; }
      body {
        margin: 0;
        background: var(--bg);
        color: var(--fg);
        font-family: var(--font-body);
        overflow: hidden;
      }
      .menubar {
        height: 40px;
        background: var(--bg);
        border-bottom: 1px solid var(--border);
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 0 12px;
      }
      .menu-item {
        padding: 6px 8px;
        border-radius: 4px;
        cursor: pointer;
        color: var(--fg);
        font-size: 13px;
      }
      .menu-item.active {
        background: var(--bg3);
      }
      .app {
        position: absolute;
        top: 40px;
        bottom: 26px;
        left: 0;
        right: 0;
        display: flex;
        min-height: 0;
      }
      .sidebar {
        width: 300px;
        background: var(--bg2);
        border-right: 1px solid var(--border);
        padding: 14px;
        display: flex;
        flex-direction: column;
        gap: 14px;
        overflow-y: auto;
      }
      .sidebar h2 {
        margin: 0;
        font-size: 12px;
        color: #bbbbbb;
        text-transform: uppercase;
        letter-spacing: 0.08em;
      }
      .sidebar input[type="file"], .sidebar select, .sidebar button {
        width: 100%;
        padding: 8px;
        margin-top: 6px;
        border: 1px solid var(--border);
        border-radius: var(--radius);
        background: var(--bg3);
        color: var(--fg);
      }
      .sidebar button {
        cursor: pointer;
      }
      .sidebar button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .content {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }
      .toolbar {
        padding: 12px;
        background: var(--bg2);
        border-bottom: 1px solid var(--border);
        display: flex;
        gap: 10px;
        align-items: center;
      }
      .toolbar input[type="text"] {
        flex: 1;
        padding: 6px;
        border: 1px solid var(--border);
        border-radius: var(--radius);
        background: var(--bg3);
        color: var(--fg);
      }
      table {
        width: 100%;
        border-collapse: collapse;
      }
      thead {
        position: sticky;
        top: 0;
        background: var(--bg2);
        z-index: 2;
      }
      th, td {
        padding: 6px 8px;
        border-bottom: 1px solid var(--border);
        font-size: 13px;
      }
      tbody tr:hover {
        background: var(--bg3);
      }
      .logs {
        height: 150px;
        overflow-y: auto;
        background: var(--bg2);
        padding: 8px;
        border-top: 1px solid var(--border);
        font-size: 12px;
        line-height: 1.4;
      }
      .status-bar {
        height: 26px;
        background: var(--bg3);
        border-top: 1px solid var(--border);
        display: flex;
        align-items: center;
        padding: 0 10px;
        font-size: 12px;
        justify-content: space-between;
      }
      .hidden { display: none; }
      .dropdown {
        width: 100%;
        padding: 6px;
        border: 1px solid var(--border);
        border-radius: var(--radius);
        background: var(--bg3);
        color: var(--fg);
      }
    </style>
  </head>
  <body>
    <div class="menubar">
      <div class="menu-item active" id="tab-cleaner" onclick="selectTab('cleaner')">Cleaner</div>
      <div class="menu-item" id="tab-about" onclick="selectTab('about')">About</div>
    </div>
    <div class="app">
      <div class="sidebar" id="sidebar-cleaner">
        <h2>1. Upload Raw Export</h2>
        <input type="file" id="fileInput" accept=".xlsx,.xls,.csv" />
        <button id="scanBtn" onclick="scanItems()">Scan Items</button>
        <div id="sessionInfo" class="hidden">
          <h2>Session</h2>
          <div id="sessionIdDisplay"></div>
          <button id="deleteSessionBtn" onclick="deleteSession()">Delete Session</button>
        </div>
        <h2>2. Select Item Numbers</h2>
        <select id="itemSelect" class="dropdown" multiple size="8"></select>
        <button id="cleanBtn" onclick="cleanSelected()" disabled>Clean Selected</button>
      </div>
      <div class="content" id="content-cleaner">
        <div class="toolbar">
          <input type="text" id="searchInput" placeholder="Search in cleaned results..." oninput="filterResults()" disabled />
          <button id="downloadBtn" onclick="downloadCleaned()" disabled>Download Cleaned</button>
        </div>
        <div style="flex:1; overflow:auto;">
          <table id="resultTable">
            <thead>
              <tr>
                <th>Item No</th>
                <th>Document Name</th>
                <th>File Paths</th>
                <th>Type Group</th>
                <th>Date Stored</th>
                <th>Document Type</th>
              </tr>
            </thead>
            <tbody id="resultBody"></tbody>
          </table>
        </div>
        <div class="logs" id="logPanel"></div>
      </div>
      <!-- About Tab -->
      <div class="content hidden" id="content-about">
        <div style="padding: 12px; overflow-y:auto; height:100%;">
          <h1>About This Cleaner</h1>
          <p>
            This application uses <strong>Supabase</strong> to process large CSV and
            Excel exports without exhausting your browser’s memory.  When you
            upload a file, it is streamed to a private <em>raw_uploads</em> bucket
            inside your Supabase project.  A unique session ID is generated and
            recorded in the <code>csv_jobs</code> table; this ID is displayed in
            the sidebar so you can track your session.  You then select which
            item numbers to clean.  When you press <strong>Clean Selected</strong>, an
            Edge Function named <code>process_csv</code> runs on the server: it
            reads your uploaded file, filters rows by item number, groups and
            deduplicates file paths using SQL, and writes results into the
            <code>cleaned_records</code> table.  Progress messages are inserted
            into <code>csv_job_logs</code>, which stream live into the log panel via
            Supabase Realtime.  Once complete, the browser fetches the cleaned
            records and displays them in an interactive table.  You can search
            within the results and download the data as an Excel file.  When you
            delete a session, all rows and files associated with that session
            are removed from your database and storage buckets.
          </p>
          <p>
            <strong>Why use Supabase?</strong>  Prior versions of this cleaner relied
            on running Python in the browser via Pyodide.  While convenient for
            small files, it struggled with large datasets and could crash the
            tab.  Offloading work to a server means you can handle much larger
            exports without putting a strain on your computer.  Supabase
            automatically scales and enforces row‑level security, ensuring that
            only data belonging to your session is accessible.  The lifecycle
            rules you set on your buckets determine when files are deleted
            automatically, so you never have to worry about leaving data
            behind.  A combination of server processing and local search
            caching gives you the best of both worlds: heavy work happens
            remotely, while searching through results is instantaneous.
          </p>
          <p>
            <strong>Tables and Policies:</strong>  This tool expects the following
            tables in your Supabase database:
          </p>
          <ul>
            <li>
              <code>csv_jobs</code> – tracks each upload with fields
              <code>id</code> (uuid primary key), <code>filename</code>, <code>status</code>,
              <code>created_at</code>, <code>completed_at</code> and <code>error</code>.
            </li>
            <li>
              <code>csv_job_logs</code> – stores log messages for each job
              (foreign key <code>job_id</code> → <code>csv_jobs.id</code>) and a
              timestamp.
            </li>
            <li>
              <code>cleaned_records</code> – temporary table holding cleaned
              rows with fields for item number, document name, file paths, type
              group, date stored and document type.  Each record is tied to
              <code>job_id</code> so it can be deleted when the session ends.
            </li>
          </ul>
          <p>
            Row level security should be enabled on all three tables.  Policies
            should allow anonymous users to insert new rows and select rows
            pertaining to their own job ID.  The Edge Function uses a service
            role key to bypass RLS so it can write logs and cleaned data.  See
            the SQL section in the instructions for the exact DDL and policy
            definitions.  By default the publishable key included in this
            template only allows reading and inserting into the allowed tables.
          </p>
          <p>
            To prevent reloading the same data repeatedly, the cleaned results
            are cached in memory on the client.  Searching or filtering the
            results operates on this local cache, so you can quickly explore
            your data without hitting the database again.  When you start
            another cleaning job, the cache is cleared.
          </p>
        </div>
      </div>
    </div>
    <div class="status-bar" id="statusBar">
      Ready.
    </div>

    <!-- External libraries -->
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script type="module">
      import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.38.2/+esm';

      // Initialise Supabase client using credentials provided by the user.
      const supabaseUrl = 'https://axkfsvaltwwpihwrdefw.supabase.co';
      const supabaseKey = 'sb_publishable_R26Ofyljfp7uHUP2FnldRA_dX1bi7np';
      const supa = createClient(supabaseUrl, supabaseKey, {
        auth: {
          persistSession: false // do not store session in local storage
        }
      });

      // Global state
      let sessionId = null;
      let filePath = null;
      let cleanedData = [];
      let logsChannel = null;
      let jobStatus = null;
      let cache = null; // to hold cached results for current session

      // UI helpers
      function setStatus(msg) {
        document.getElementById('statusBar').textContent = msg;
      }
      function appendLog(msg) {
        const logPanel = document.getElementById('logPanel');
        logPanel.textContent += msg + '\n';
        logPanel.scrollTop = logPanel.scrollHeight;
      }
      function clearLogs() {
        document.getElementById('logPanel').textContent = '';
      }

      // Tab switching
      window.selectTab = function(tab) {
        document.getElementById('tab-cleaner').classList.toggle('active', tab === 'cleaner');
        document.getElementById('tab-about').classList.toggle('active', tab === 'about');
        document.getElementById('sidebar-cleaner').classList.toggle('hidden', tab !== 'cleaner');
        document.getElementById('content-cleaner').classList.toggle('hidden', tab !== 'cleaner');
        document.getElementById('content-about').classList.toggle('hidden', tab !== 'about');
      };

      // Scan the selected file for unique item numbers and create a job
      window.scanItems = async function() {
        const fileInput = document.getElementById('fileInput');
        const file = fileInput.files[0];
        if (!file) {
          alert('Please choose a file first.');
          return;
        }
        setStatus('Scanning file for unique item numbers…');
        // Reset UI
        document.getElementById('itemSelect').innerHTML = '';
        document.getElementById('cleanBtn').disabled = true;
        document.getElementById('searchInput').disabled = true;
        document.getElementById('downloadBtn').disabled = true;
        clearLogs();

        // Read only first sheet or CSV to gather item numbers
        const buf = await file.arrayBuffer();
        let workbook;
        try {
          workbook = XLSX.read(buf, { type: 'array' });
        } catch (err) {
          console.error(err);
          setStatus('Failed to parse file.');
          return;
        }
        // Take first sheet
        const firstSheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[firstSheetName];
        const data = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });
        // Find column index for Item No by searching header row (first non-empty row)
        let header = data.find(row => row.some(cell => cell !== '')) || [];
        let itemIndex = header.findIndex(cell => /item.*no/i.test(String(cell)));
        if (itemIndex === -1) itemIndex = 0; // fallback to first column
        const unique = new Set();
        for (let i = 1; i < data.length; i++) {
          const val = String(data[i][itemIndex]).trim();
          if (val) unique.add(val);
          // Limit scanning to first 2000 rows to avoid memory pressure
          if (unique.size > 200 && i > 2000) break;
        }

        const items = Array.from(unique).sort();
        // Create or update session
        // If no session exists, insert a new job row
        let jobResponse;
        if (!sessionId) {
          jobResponse = await supa.from('csv_jobs').insert({ filename: file.name, status: 'uploaded' }).select().single();
          if (jobResponse.error) {
            alert('Failed to create job: ' + jobResponse.error.message);
            setStatus('Failed to create session.');
            return;
          }
          sessionId = jobResponse.data.id;
        }
        // Build file path: use sessionId as folder
        filePath = `${sessionId}/${file.name}`;
        // Upload file to raw_uploads bucket
        const { error: uploadErr } = await supa.storage.from('raw_uploads').upload(filePath, file, { contentType: file.type, upsert: true });
        if (uploadErr) {
          alert('Upload failed: ' + uploadErr.message);
          setStatus('Failed to upload.');
          return;
        }
        // Show session info
        document.getElementById('sessionInfo').classList.remove('hidden');
        document.getElementById('sessionIdDisplay').textContent = sessionId;
        // Populate select list
        const select = document.getElementById('itemSelect');
        items.forEach(it => {
          const opt = document.createElement('option');
          opt.value = it;
          opt.textContent = it;
          select.appendChild(opt);
        });
        document.getElementById('cleanBtn').disabled = items.length === 0;
        setStatus(`Found ${items.length} unique item numbers. Ready to clean.`);
      };

      // Invoke the Edge Function to clean selected items
      window.cleanSelected = async function() {
        const options = Array.from(document.getElementById('itemSelect').selectedOptions);
        const selected = options.map(o => o.value);
        if (selected.length === 0) {
          alert('Please select at least one item number to clean.');
          return;
        }
        setStatus('Invoking cleaning job…');
        clearLogs();
        // Subscribe to logs for this session
        if (logsChannel) {
          supa.removeChannel(logsChannel);
        }
        logsChannel = supa.channel('job_logs_' + sessionId)
          .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'csv_job_logs', filter: 'job_id=eq.' + sessionId }, payload => {
            const message = payload.new.message;
            appendLog(message);
          })
          .subscribe();
        // Start job via Edge Function
        try {
          const { data, error } = await supa.functions.invoke('process_csv', {
            body: { job_id: sessionId, file_path: filePath, item_numbers: selected }
          });
          if (error) {
            appendLog('Error invoking function: ' + error.message);
            setStatus('Error running job.');
            return;
          }
        } catch (err) {
          appendLog('Error: ' + err.message);
          setStatus('Error running job.');
          return;
        }
        setStatus('Job started. Waiting for completion…');
        // Poll job status until completed
        const poll = async () => {
          const { data: job, error } = await supa.from('csv_jobs').select().eq('id', sessionId).single();
          if (error) {
            console.error('Status poll error', error);
            setTimeout(poll, 2000);
            return;
          }
          if (job.status === 'completed') {
            jobStatus = 'completed';
            appendLog('Job completed. Fetching cleaned data…');
            setStatus('Fetching cleaned data…');
            await fetchCleaned();
            return;
          } else if (job.status === 'error') {
            jobStatus = 'error';
            appendLog('Job encountered an error: ' + job.error);
            setStatus('Job failed.');
            return;
          } else {
            jobStatus = job.status;
            setTimeout(poll, 2000);
          }
        };
        poll();
      };

      // Fetch cleaned records from Supabase and cache
      async function fetchCleaned() {
        const { data: records, error } = await supa.from('cleaned_records').select('*').eq('job_id', sessionId);
        if (error) {
          appendLog('Error fetching cleaned data: ' + error.message);
          setStatus('Failed to fetch cleaned data.');
          return;
        }
        cleanedData = records.map(row => ({
          item_no: row.item_no,
          document_name: row.document_name,
          file_paths: row.file_path,
          type_group: row.document_type_group,
          date_stored: row.date_stored,
          document_type: row.document_type
        }));
        cache = cleanedData.slice();
        renderResults(cleanedData);
        document.getElementById('searchInput').disabled = false;
        document.getElementById('downloadBtn').disabled = cleanedData.length === 0;
        setStatus(`Loaded ${cleanedData.length} cleaned records.`);
      }

      // Render cleanedData to table
      function renderResults(data) {
        const tbody = document.getElementById('resultBody');
        tbody.innerHTML = '';
        data.forEach(row => {
          const tr = document.createElement('tr');
          ['item_no', 'document_name', 'file_paths', 'type_group', 'date_stored', 'document_type'].forEach(key => {
            const td = document.createElement('td');
            td.textContent = row[key];
            tr.appendChild(td);
          });
          tbody.appendChild(tr);
        });
      }

      // Search within cleaned results
      window.filterResults = function() {
        const q = document.getElementById('searchInput').value.toLowerCase();
        if (!cache) return;
        if (!q) {
          renderResults(cache);
          return;
        }
        const filtered = cache.filter(row => {
          return Object.values(row).some(val => String(val).toLowerCase().includes(q));
        });
        renderResults(filtered);
      };

      // Download cleaned data as an Excel file compressed into a zip
      window.downloadCleaned = async function() {
        if (!cache || cache.length === 0) return;
        setStatus('Preparing download…');
        // Convert to worksheet
        const ws = XLSX.utils.json_to_sheet(cache);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, 'Cleaned');
        const wbBlob = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
        // Create zip
        const zip = new JSZip();
        zip.file('cleaned.xlsx', wbBlob);
        const content = await zip.generateAsync({ type: 'blob' });
        const url = URL.createObjectURL(content);
        const link = document.createElement('a');
        link.href = url;
        link.download = `cleaned_${sessionId}.zip`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        setStatus('Download ready.');
      };

      // Delete session: remove data and storage files
      window.deleteSession = async function() {
        if (!sessionId) return;
        if (!confirm('This will delete all data for this session. Continue?')) return;
        setStatus('Deleting session…');
        clearLogs();
        // Delete storage files
        await supa.storage.from('raw_uploads').remove([filePath]);
        await supa.storage.from('cleaned_output').remove([`${sessionId}/cleaned.xlsx`]);
        // Delete records
        await supa.from('cleaned_records').delete().eq('job_id', sessionId);
        await supa.from('csv_job_logs').delete().eq('job_id', sessionId);
        await supa.from('csv_jobs').delete().eq('id', sessionId);
        // Reset state
        sessionId = null;
        filePath = null;
        cleanedData = [];
        cache = null;
        document.getElementById('sessionInfo').classList.add('hidden');
        document.getElementById('sessionIdDisplay').textContent = '';
        document.getElementById('itemSelect').innerHTML = '';
        document.getElementById('cleanBtn').disabled = true;
        document.getElementById('searchInput').disabled = true;
        document.getElementById('downloadBtn').disabled = true;
        document.getElementById('resultBody').innerHTML = '';
        setStatus('Session deleted. Ready.');
      };
    </script>
  </body>
</html>
